<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Code and Output</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        pre { background: #f4f4f4; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        code { font-family: Consolas, monospace; font-size: 14px; }
        h1, h2 { color: #333; }
    </style>
</head>
<body>
    <h1>Python Source Code</h1>
    <pre><code># -*- coding: utf-8 -*-
&quot;&quot;&quot;Actividad7

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m-W-roLWNofWg2zzR8XRIl46Wy678k_A
&quot;&quot;&quot;

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import yfinance as yf
import warnings
warnings.filterwarnings(&#x27;ignore&#x27;)

# Test de Dickey-Fuller Aumentado
def adf_test(series, title=&#x27;&#x27;):
    print(f&#x27;Augmented Dickey-Fuller Test: {title}&#x27;)
    result = adfuller(series.dropna(), autolag=&#x27;AIC&#x27;)
    labels = [&#x27;ADF Test Statistic&#x27;, &#x27;p-value&#x27;, &#x27;# Lags Used&#x27;, &#x27;Number of Observations Used&#x27;]
    out = pd.Series(result[0:4], index=labels)
    for key, value in result[4].items():
        out[f&#x27;Critical Value ({key})&#x27;] = value
    print(out.to_string())
    if result[1] &lt;= 0.05:
        print(&quot;‚Üí Serie estacionaria (se rechaza H0)\n&quot;)
    else:
        print(&quot;‚Üí Serie NO estacionaria (no se rechaza H0)\n&quot;)

# Aplicar diferenciaci√≥n hasta volver estacionaria la serie
def make_stationary(series, max_diff=2):
    d = 0
    temp_series = series.copy()
    while d &lt;= max_diff:
        result = adfuller(temp_series.dropna(), autolag=&#x27;AIC&#x27;)
        p_value = result[1]
        if p_value &lt;= 0.05:
            print(f&quot;‚úî Serie estacionaria tras {d} diferenciaci√≥n(es).&quot;)
            return temp_series, d
        else:
            temp_series = temp_series.diff()
            d += 1
    print(&quot;‚úò No se logr√≥ estacionar la serie con el n√∫mero m√°ximo de diferenciaciones.&quot;)
    return temp_series, d

# Medias m√≥viles
def moving_average(data, window):
    return data.rolling(window=window).mean()

# Correlograma ACF y PACF
def plot_correlogram(series, lags=40, title=&#x27;&#x27;):
    plt.figure(figsize=(14, 5))
    plt.subplot(121)
    sm.graphics.tsa.plot_acf(series.dropna(), lags=lags, ax=plt.gca(), title=f&#x27;ACF - {title}&#x27;)
    plt.subplot(122)
    sm.graphics.tsa.plot_pacf(series.dropna(), lags=lags, ax=plt.gca(), title=f&#x27;PACF - {title}&#x27;)
    plt.tight_layout()
    plt.show()

# Simulaci√≥n de caminata aleatoria
def plot_random_walk(stock_data, ticker):
    stock_diff = stock_data.diff().dropna()
    step_std = stock_diff.std()
    np.random.seed(42)
    n_steps = len(stock_data)
    steps = np.random.normal(0, step_std, n_steps)
    random_walk = np.cumsum(steps) + stock_data.iloc[0]
    df = pd.DataFrame({
        &#x27;Actual&#x27;: stock_data,
        &#x27;Random Walk&#x27;: random_walk
    }, index=stock_data.index)
    plt.figure(figsize=(14, 7))
    plt.plot(df[&#x27;Actual&#x27;], label=&#x27;Actual Adjusted Close Prices&#x27;, color=&#x27;black&#x27;)
    plt.plot(df[&#x27;Random Walk&#x27;], label=&#x27;Simulated Random Walk&#x27;, color=&#x27;red&#x27;, linestyle=&#x27;--&#x27;)
    plt.title(f&#x27;{ticker} - Actual Prices vs. Simulated Random Walk&#x27;)
    plt.xlabel(&#x27;Date&#x27;)
    plt.ylabel(&#x27;Price&#x27;)
    plt.legend()
    plt.show()

# Test de cointegraci√≥n de Johansen
def cointegration_test(df):
    print(&quot;\nJohansen Cointegration Test:&quot;)
    try:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print(f&quot;Trace statistic: {result.lr1}&quot;)
        print(f&quot;Critical values (90%, 95%, 99%): {result.cvt}&quot;)
        for i in range(len(result.lr1)):
            if result.lr1[i] &gt; result.cvt[i, 1]:  # 95%
                print(f&quot;r = {i}: Existe cointegraci√≥n (95%)&quot;)
            else:
                print(f&quot;r = {i}: No hay cointegraci√≥n (95%)&quot;)
        print(&quot;\n&quot;)
    except Exception as e:
        print(f&quot;Error en el test de Johansen: {e}\n&quot;)



# Ajuste ARIMA sobre serie diferenciada y forecast (con reintegraci√≥n)
def fit_arima(series, ticker, order=(1,1,1), forecast_steps=30):
    try:
        d = order[1]  # Grado de diferenciaci√≥n
        if d &gt; 0:
            # Diferenciar la serie para volverla estacionaria
            differenced_series = series.diff(d).dropna()
        else:
            differenced_series = series.dropna()

        # Ajustar el modelo sobre la serie diferenciada
        model = ARIMA(differenced_series, order=(order[0], 0, order[2]))  # d=0 porque ya se aplic√≥ manualmente
        results = model.fit()
        print(f&#x27;ARIMA Model Summary para {ticker} (diferenciada d={d}):&#x27;)
        print(results.summary())

        # Forecast en la serie diferenciada
        forecast_diff = results.get_forecast(steps=forecast_steps)
        forecast_mean_diff = forecast_diff.predicted_mean

        # Reintegrar para volver a escala original
        last_value = series.dropna().iloc[-1]
        forecast_values = forecast_mean_diff.cumsum() + last_value

        # Crear √≠ndice futuro (business days desde el √∫ltimo d√≠a)
        forecast_index = pd.date_range(start=series.index[-1], periods=forecast_steps + 1, freq=&#x27;B&#x27;)[1:]
        forecast_series = pd.Series(forecast_values.values, index=forecast_index)

        # Graficar
        plt.figure(figsize=(14, 7))
        plt.plot(series, label=&#x27;Precio Hist√≥rico&#x27;)
        plt.plot(forecast_series, label=&#x27;Pron√≥stico ARIMA (Reintegrado)&#x27;, color=&#x27;red&#x27;)
        plt.title(f&#x27;{ticker} - ARIMA Forecast con diferenciaci√≥n (d={d})&#x27;)
        plt.xlabel(&#x27;Fecha&#x27;)
        plt.ylabel(&#x27;Precio&#x27;)
        plt.legend()
        plt.show()

        return results.aic
    except Exception as e:
        print(f&quot;Error fitting ARIMA para {ticker}: {e}&quot;)
        return np.inf

# Descargar datos de Yahoo Finance
tickers = [&#x27;LLY&#x27;, &#x27;WELL&#x27;, &#x27;WFC&#x27;, &#x27;JPM&#x27;]
start_date = &#x27;2024-09-02&#x27;
end_date = &#x27;2025-06-09&#x27;

data = yf.download(tickers, start=start_date, end=end_date)

# Usar precios ajustados
data = data[&#x27;Adj Close&#x27;] if &#x27;Adj Close&#x27; in data.columns else data[&#x27;Close&#x27;]

# Diccionario para almacenar AIC de cada modelo
aic_scores = {}

# An√°lisis por acci√≥n
for ticker in tickers:
    print(f&#x27;\n\n=== An√°lisis para {ticker} ===\n&#x27;)

    stock_data = data[ticker]

    # ADF test original
    adf_test(stock_data, title=f&#x27;{ticker} - Serie original&#x27;)

    # Simulaci√≥n de caminata aleatoria
    plot_random_walk(stock_data, ticker)

    # Volver estacionaria la serie
    stationary_series, d = make_stationary(stock_data)

    # ADF de serie estacionaria
    adf_test(stationary_series, title=f&#x27;{ticker} - Serie diferenciada&#x27;)

    # Correlograma
    plot_correlogram(stationary_series, title=f&#x27;{ticker} - Serie estacionaria (d={d})&#x27;)

    # Medias m√≥viles
    ma_9 = moving_average(stock_data, 9)
    ma_30 = moving_average(stock_data, 30)

    plt.figure(figsize=(14, 7))
    plt.plot(stock_data, label=&#x27;Precios Ajustados&#x27;)
    plt.plot(ma_9, label=&#x27;Media m√≥vil 9 d√≠as&#x27;)
    plt.plot(ma_30, label=&#x27;Media m√≥vil 30 d√≠as&#x27;)
    plt.title(f&#x27;{ticker} - Precios y Medias M√≥viles&#x27;)
    plt.legend()
    plt.show()

    # Ajustar ARIMA
    aic_scores[ticker] = fit_arima(stock_data, ticker, order=(1, d, 1))


# Test de cointegraci√≥n
coint_df = pd.DataFrame({
    &#x27;LLY&#x27;: data[&#x27;LLY&#x27;],
    &#x27;WELL&#x27;: data[&#x27;WELL&#x27;],
    &#x27;WFC&#x27;: data[&#x27;WFC&#x27;],
    &#x27;JPM&#x27;: data[&#x27;JPM&#x27;]
}).dropna()
cointegration_test(coint_df)


# Comparaci√≥n final
print(&quot;\n=== Comparaci√≥n de inversiones ===&quot;)
print(&quot;AIC menor = mejor ajuste del modelo ARIMA.\n&quot;)
for ticker, aic in aic_scores.items():
    print(f&quot;{ticker} ‚Üí AIC: {aic:.2f}&quot;)
best_stock = min(aic_scores, key=aic_scores.get)
print(f&quot;\n‚úî Recomendaci√≥n basada en ARIMA: {best_stock}&quot;)
print(&quot;Nota: Si hay cointegraci√≥n, considera estrategia de &#x27;pairs trading&#x27;.&quot;)

&quot;&quot;&quot;INTERPRETACIONES DE RESULTADOS AL EVALUAR LAS ACCIONES EN EL C√ìDIGO:
Interpretaci√≥n de los resultados de raiz unitaria, correlograma (ACF y PACF) , ADF, cointegration , random walk

# LLY
1. AN√ÅLISIS DE RA√çZ UNITARIA Y ESTACIONARIEDAD
Serie Original:

ADF Statistic: -2.549830 (p-value: 0.103816)
Resultado: NO estacionaria (no se rechaza H‚ÇÄ) EL P VALUE &gt;0.05
Interpretaci√≥n: LLY tiene ra√≠z unitaria, confirma proceso estoc√°stico con tendencia, sugiere que los datos de LLY probablemente exhiben un paseo aleatorio con deriva. Esta es una caracter√≠stica com√∫n de muchas series de tiempo financieras, donde los precios tienden a moverse

Serie Diferenciada (d=1):
ADF Statistic: -6.914764 (p-value: 1.187√ó10‚Åª‚Åπ)
Resultado: Estacionaria (se rechaza H‚ÇÄ)
Interpretaci√≥n: Una diferenciaci√≥n es suficiente para lograr estacionariedad, esto hace que se elimine ra√≠z y hacer que las propiedades estad√≠sticas de la serie sean tendencia m√°s constantes en el tiempo.
2. Correologramas:

ACF - La ca√≠da r√°pida y la no significancia de la mayor√≠a de los lags en la ACF confirman la estacionariedad de la serie de LLY (d=1), ya determinado con la prueba ADF. El pico significativo en el lag 1 y luego laca√≠da a insignificancia en los lags subsiguientes de la ACF es un patr√≥n indicativo de un componente de Media M√≥vil (MA)
PACF - muestra un patr√≥n de corte claro o decaimiento exponencial para lags m√°s all√° del 1, sugiere que un componente autorregresivo (AR) de orden 0 o muy bajo podr√≠a ser apropiado.
3. Random walk:

Muestran movimientos err√°ticos y aparentemente impredecibles en el tiempo. Aunque pueden observarse tendencias generales a mediano plazo (mejor suavizadas por las medias m√≥viles), la direcci√≥n precisa de un movimiento futuro individual de precios no puede ser pronosticada con certeza a partir de los movimientos pasados, lo cual es la esencial en mercados eficientes.
4. Arima

Los coeficientes ar.L1, ma.L1 y const no son estad√≠sticamente significativos (sus p-valores son muy altos, cercanos a 1). Esto implica que el modelo ARIMA(1,1,1) con constante no encuentra patrones predictivos significativos en los datos diferenciados de LLY. El pron√≥stico muestra una leve tendencia descendente para los precios de LLY desde principios de junio hasta finales de julio de 2025. El precio proyectado final es de aproximadamente 740-745, aunque no es estad√≠sticamente fiable, sin embargo convendria no comprar la accion por la tendencia de la gr√°fica.


# WELL

1. AN√ÅLISIS DE RA√çZ UNITARIA Y ESTACIONARIEDAD

Ra√≠z Unitaria y Comportamiento Inicial de los Precios:
Los resultados del test de Dickey-Fuller Aumentado (ADF) muestran un p-valor alto (0.842258) y un estad√≠stico de prueba mayor que los valores cr√≠ticos, lo cual indica que no podemos rechazar la hip√≥tesis nula de presencia de ra√≠z unitaria. Por lo que no es estacionaria y sigue un comportamiento sugiere que la serie original no presenta patrones consistentes en media o varianza a lo largo del tiempo, lo cual limita la capacidad de predecir precios futuros directamente a partir de los precios al presentarse ser muy variables.

Despu√©s de la Diferenciaci√≥n, el test ADF muestra un estad√≠stico altamente negativo (-7.00) y un p-valor pr√°cticamente cero (7.37e-10). Esto nos permite rechazar con confianza la hip√≥tesis nula de ra√≠z unitaria, lo que indica que la serie diferenciada s√≠ es estacionaria. Esto crucial para el modelado estad√≠stico, ya que una serie estacionaria posee una media, varianza y estructura de autocorrelaci√≥n constantes en el tiempo. Esto significa que los patrones en los cambios de precios son m√°s estables y predecibles, lo que permite aplicar con mayor precisi√≥n modelos como ARIMA para realizar pron√≥sticos confiables.

2. Correologramas:

El an√°lisis de la Funci√≥n de Autocorrelaci√≥n (ACF) muestra una estructura con memoria corta, donde la mayor√≠a de las correlaciones est√°n cerca de cero. Aunque hay ligeros picos en los lags 20 y 40, que podr√≠an sugerir una estacionalidad d√©bil, el comportamiento general indica que la serie se comporta casi como ruido blanco. Por su parte, la Funci√≥n de Autocorrelaci√≥n Parcial (PACF) presenta valores bajos y dispersos, sin cortes abruptos, lo que sugiere una estructura AR d√©bil y confirma que la serie diferenciada es estacionaria.

Con base en estos patrones, se recomienda un modelo ARIMA(0,1,1) o ARIMA(1,1,0), ya que tanto ACF como PACF muestran disminuciones r√°pidas despu√©s del primer rezago.

3. Random walk:

Los precios se mueven de forma err√°tica e impredecible en el corto plazo, sin patrones claros ni reversi√≥n a la media. Los shocks en el precio persisten en el tiempo, y aunque se observan tendencias generales (alcistas o bajistas), estas emergen como resultado acumulado de movimientos aleatorios. Las medias m√≥viles suavizan ese ruido, revelando tendencias subyacentes, pero no eliminan la aleatoriedad del precio, lo que refuerza la idea de que predecir el precio futuro solo con base en el pasado es altamente incierto.

4. Arima

Aunque el modelo ARIMA(1,1,1) aplicado a los precios de WELL muestra coeficientes no estad√≠sticamente significativos, el pron√≥stico generado exhibe una tendencia alcista moderada que, aunque no robusta, podr√≠a reflejar una inercia positiva del mercado. A pesar del comportamiento cercano a un random walk, el hecho de que los residuos se comporten como ruido blanco y que la serie muestre una trayectoria creciente en el gr√°fico sugiere que podr√≠a haber una oportunidad de corto plazo. Si se combina este indicio con se√±ales favorables de an√°lisis t√©cnico y perspectivas positivas desde un an√°lisis fundamental, es buena la decisi√≥n de compra siempre considerando el riesgo inherente a la volatilidad y la limitada capacidad predictiva del modelo.

# JPM

1. AN√ÅLISIS DE RA√çZ UNITARIA Y ESTACIONARIEDAD

El p-value (0.553170) es significativamente mayor que cualquier nivel de significancia com√∫n (0.01, 0.05, 0.10). Adem√°s, el ADF Test Statistic (-1.460057) es mayor que los valores cr√≠ticos en todos los niveles. Esto nos lleva a no rechazar la hip√≥tesis nula (H0) de la prueba ADF. La H0 en este contexto es que la serie tiene una ra√≠z unitaria. JPM sigue un proceso estoc√°stico con una tendencia o un paseo aleatorio, donde los shocks a los precios tienen un efecto permanente y la media/varianza no son constantes en el tiempo.
Una diferenciaci√≥n (d=1) ha sido suficiente para lograr la estacionariedad en la serie de JPM. Esto significa que al tomar los cambios (diferencias) entre los precios consecutivos, la serie resultante tiene una media y varianza constantes a lo largo del tiempo, lo cual es fundamental para aplicar modelos de series de tiempo como los modelos ARIMA. El p-value (5.57e-26) es pr√°cticamente cero y significativamente menor que cualquier nivel de significancia. El ADF Test Statistic (-13.91) es mucho m√°s negativo que el Critical Value al 1% (-3.465). Esto nos permite rechazar la hip√≥tesis nula (H0).


2. Correologramas:

El gr√°fico de ACF a partir del rezago 1, las autocorrelaciones caen bruscamente y se mantienen dentro de las bandas de confianza. Esto indica que no existe una autocorrelaci√≥n significativa entre los valores actuales y los pasados, lo cual sugiere que no hay un componente MA en la serie. PACF luego cae r√°pidamente, sin mostrar valores estad√≠sticamente significativos en los rezagos posteriores. Esto significa que no hay una relaci√≥n directa entre los valores actuales y sus rezagos anteriores, una vez eliminada la influencia de los lags intermedios. Por ello, no se identifica un componente autorregresivo importante, lo que sugiere un valor de  ùëù = 0 p=0.  Conclusi√≥n: Tanto el ACF como el PACF confirman que la serie diferenciada de JPM no presenta patrones autoregresivos ni de media m√≥vil significativos.

3. Random walk:

Los precios ajustados fluct√∫an de forma err√°tica sin un patr√≥n claro, haciendo dif√≠cil predecir el precio futuro bas√°ndose solo en movimientos recientes. Los cambios en el precio se incorporan y mantienen en el tiempo, sin volver r√°pidamente a niveles previos, creando nuevos rangos o niveles.

Aunque los movimientos diarios son aleatorios, la suma de estos pasos puede generar tendencias visibles a medio-largo plazo (ej. tendencia alcista entre septiembre 2024 y marzo 2025, ca√≠da en abril y recuperaci√≥n en mayo-junio).

Las medias m√≥viles suavizan la volatilidad, ayudando a identificar estas tendencias subyacentes. Podemos ver por ejmeplo que cruces entre ellas suelen se√±alar cambios en la tendencia.


4. Arima

El modelo ARIMA(1,1,1) aplicado a los precios diferenciados de JPM con 190 observaciones muestra coeficientes no estad√≠sticamente significativos (constante 0.2590, p=0.424; AR(1) -0.8913, p=0.676; MA(1) 0.8953, p=0.673), lo que indica que no se capturan patrones lineales claros en la serie. Sin embargo, la varianza de los residuos es 19.39 es significativa, y las pruebas de autocorrelaci√≥n (Ljung-Box p=0.76) y homocedasticidad (p=0.25) sugieren un modelo estable y sin autocorrelaci√≥n en errores. El pron√≥stico del modelo indica una tendencia de subida clara desde junio hasta julio de 2025, con un aumento proyectado en el precio ajustado de aproximadamente 265 a entre 275 y 280. Esta tendencia, aunque basada en coeficientes con significancia limitada, puede interpretarse como una se√±al positiva derivada de la reintegraci√≥n y acumulaci√≥n de movimientos en la serie diferenciada. Adem√°s, la ausencia de heterocedasticidad reduce riesgos asociados a volatilidad extrema en los errores del modelo. Por lo tanto, considerando la tendencia proyectada y la estabilidad del modelo, la compra de JPM podr√≠a  ser una oportunidad para aprovechar este probable crecimiento de precio en el mediano plazo.

# WFC

1. AN√ÅLISIS DE RA√çZ UNITARIA Y ESTACIONARIEDAD

La serie original de precios de WFC fue evaluada con la prueba de Dickey-Fuller Aumentada (ADF). El estad√≠stico ADF fue de -1.5987 con un p-valor de 0.4842, que es mucho mayor al nivel de significancia del 0.05. Adem√°s, el valor del estad√≠stico es menos negativo que el valor cr√≠tico al 5% (-2.8769), por lo que no se rechaza la hip√≥tesis nula de ra√≠z unitaria. Esto indica que la serie original es no estacionaria y se comporta como un random walk, lo que significa que los shocks son permanentes y las propiedades estad√≠sticas como la media y la varianza cambian con el tiempo.

Tras aplicar una diferenciaci√≥n de orden 1 (d=1), se realiz√≥ nuevamente la prueba ADF sobre la serie diferenciada. En este caso, el estad√≠stico fue aproximadamente -13.22 con un p-valor pr√°cticamente cero (1.02e-24), mucho menor que 0.05, y el estad√≠stico es mucho m√°s negativo que el valor cr√≠tico. Por lo tanto, se rechaza la hip√≥tesis nula y se concluye que la serie diferenciada es estacionaria. Esto confirma que una diferenciaci√≥n es suficiente para eliminar la ra√≠z unitaria, un requisito fundamental para aplicar modelos ARIMA.

2. Correologramas:

ACF (Autocorrelaci√≥n): Se observa un pico significativo en el lag 0, pero las autocorrelaciones para lags posteriores caen r√°pidamente y no son estad√≠sticamente significativas, ya que todas las barras se encuentran dentro de las bandas de confianza. Esto confirma la estacionariedad y sugiere que no existe un componente de media m√≥vil relevante, indicando un orden q=0.

PACF (Autocorrelaci√≥n Parcial): Similarmente, hay un pico significativo en el lag 0, con ca√≠da r√°pida y ausencia de autocorrelaciones parciales significativas en lags posteriores, confirmando la estacionariedad y se√±alando que no hay un componente autorregresivo significativo, lo que implica un orden p=0.

3. Random walk:

Los precios ajustados de WFC muestran un patr√≥n err√°tico, con subidas y bajadas que no siguen una estructura clara. Esto fue confirmado por la prueba de Dickey-Fuller aumentada, donde el estad√≠stico ADF fue de -1.5987 con un p-value de 0.4842, muy por encima del umbral de 0.05. Al no poder rechazar la hip√≥tesis nula, se concluye que la serie presenta una ra√≠z unitaria y es no estacionaria. Esto significa que WFC sigue un random walk, donde los shocks de precio tienen efectos permanentes y los datos pasados no son √∫tiles para predecir los movimientos futuros.

4. Arima

Despu√©s de aplicar una diferenciaci√≥n (d=1), la serie de WFC se volvi√≥ estacionaria (ADF = -13.22, p-value ‚âà 0), lo que permiti√≥ ajustar un modelo ARIMA(1,1,1). Aunque los coeficientes del modelo ‚Äîconstante (0.0996), AR(1) (-0.0617) y MA(1) (0.0943)‚Äî no resultaron estad√≠sticamente significativos, el comportamiento de los residuos fue adecuado (ruido blanco, sin heterocedasticidad). Adem√°s, el pron√≥stico muestra una tendencia moderada a la subida, con precios proyectados que suben de $76 a casi $79 entre junio y julio de 2025. Esta proyecci√≥n, aunque estad√≠sticamente moderada, puede respaldar una decisi√≥n de compra t√°ctica.

##Cointegration

El Test de Cointegraci√≥n de Johansen aplicado a las series muestra que ninguna de las estad√≠sticas de traza (36.40, 18.59, 6.69 y 2.10) supera los valores cr√≠ticos al 95% (47.85, 29.80, 15.49 y 3.84, respectivamente) para ninguno de los posibles rangos de cointegraci√≥n (r = 0, 1, 2, 3). Esto indica que no existe una relaci√≥n de cointegraci√≥n entre las variables analizadas, es decir, no est√°n vinculadas en el largo plazo. En t√©rminos pr√°cticos, cada una sigue su propia trayectoria sin moverse de forma conjunta de manera estable, lo que respalda la hip√≥tesis de que estas series siguen comportamientos independientes y aleatorios (random walks).

&quot;&quot;&quot;

import pandas as pd
import yfinance as yf
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import itertools
import warnings
warnings.filterwarnings(&#x27;ignore&#x27;)

# Function to perform Johansen cointegration test for a pair
def cointegration_test(df, pair_name=&#x27;&#x27;):
    if df.dropna().empty or len(df.dropna()) &lt; 2:
        print(f&quot;Johansen Cointegration Test for {pair_name}: Insufficient data to perform test&quot;)
        return
    print(f&quot;\nJohansen Cointegration Test for {pair_name}:&quot;)
    try:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print(f&quot;Trace statistic: {result.lr1}&quot;)
        print(f&quot;Critical values (90%, 95%, 99%): {result.cvt}&quot;)
        cointegrated = False
        for i in range(len(result.lr1)):
            if result.lr1[i] &gt; result.cvt[i, 1]:  # 95% critical value
                print(f&quot;r = {i}: Cointegration exists at 95% confidence level&quot;)
                if i == 0:
                    cointegrated = True
            else:
                print(f&quot;r = {i}: No cointegration at 95% confidence level&quot;)
        print(f&quot;\nInterpretation for {pair_name}:&quot;)
        if cointegrated:
            print(f&quot;The pair {pair_name} is cointegrated at the 95% confidence level. This suggests a long-term equilibrium relationship, making it suitable for pairs trading strategies, as deviations from the equilibrium are likely to revert.&quot;)
        else:
            print(f&quot;The pair {pair_name} is not cointegrated at the 95% confidence level. The stocks likely move independently, and pairs trading may not be effective.&quot;)
        print(&quot;\n&quot;)
    except Exception as e:
        print(f&quot;Error in Johansen test for {pair_name}: {e}\n&quot;)

# Function to perform pairwise cointegration tests
def pairwise_cointegration_test(data, tickers):
    print(&quot;\n=== Pairwise Cointegration Tests ===&quot;)
    pairs = list(itertools.combinations(tickers, 2))
    for ticker1, ticker2 in pairs:
        # Prepare DataFrame for the pair
        coint_df = pd.DataFrame({
            ticker1: data[ticker1],
            ticker2: data[ticker2]
        }).dropna()
        # Run cointegration test for the pair
        pair_name = f&quot;{ticker1}-{ticker2}&quot;
        cointegration_test(coint_df, pair_name)

# Load data from Yahoo Finance with retry logic
tickers = [&#x27;LLY&#x27;, &#x27;WELL&#x27;, &#x27;WFC&#x27;, &#x27;JPM&#x27;]
start_date = &#x27;2024-09-02&#x27;
end_date = &#x27;2025-06-09&#x27;

def fetch_data(tickers, start_date, end_date, retries=3):
    for attempt in range(retries):
        try:
            data = yf.download(tickers, start=start_date, end=end_date, timeout=10)
            if data.empty:
                print(&quot;No data retrieved. Retrying...&quot;)
                continue
            return data
        except Exception as e:
            print(f&quot;Attempt {attempt + 1} failed: {e}&quot;)
            if attempt + 1 == retries:
                print(&quot;Max retries reached. Exiting.&quot;)
                return None
    return None

data = fetch_data(tickers, start_date, end_date)
if data is None or data.empty:
    print(&quot;Failed to retrieve data. Please check network or try later.&quot;)
    exit()

# Use Adjusted Close prices
if &#x27;Adj Close&#x27; not in data.columns:
    data = data[&#x27;Close&#x27;]
else:
    data = data[&#x27;Adj Close&#x27;]

# Perform pairwise cointegration tests
pairwise_cointegration_test(data, tickers)

&quot;&quot;&quot;##Conclusi√≥n Cointegraci√≥n

Con base en los resultados de los tests de cointegraci√≥n de Johansen para los pares LLY-WELL, LLY-WFC, LLY-JPM, WELL-WFC, WELL-JPM y WFC-JPM, ninguno muestra evidencia de cointegraci√≥n al 95% de confianza. En todos los casos, las estad√≠sticas de traza son inferiores a los valores cr√≠ticos correspondientes, lo que indica que estas acciones no mantienen una relaci√≥n estable de largo plazo. Por lo tanto, las acciones analizadas tienden a moverse de forma independiente y no ser√≠a recomendable aplicar estrategias de pairs trading, ya que no se sustentan en una relaci√≥n cointegrada. Es probable que sea necesario un periodo de tiempo mas largo, en el cual sea posible identificar comportamiento de integraci√≥n entre si.
&quot;&quot;&quot;

</code></pre>
    <h2>Execution Output</h2>
    <pre><code>Error executing code: name &#x27;adfuller&#x27; is not defined</code></pre>
</body>
</html>
